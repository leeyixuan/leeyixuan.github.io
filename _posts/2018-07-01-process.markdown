---
layout:     post
title:      "用户输入URL之后发生什么"
subtitle:   ""
date:       2018-7-1
author:     "leeyixuan"
header-img: "img/background/post-bg-js.jpg"
tags:
    - js
---

## 1. 浏览器开启网络请求线程
浏览器会根据URL，解析出得协议，开辟一个网络线程，准备前往请求资源。
>浏览器渲染进程（浏览器内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）



## 2. DNS域名解析，获取IP地址（直接输入IP地址，则可略过该步骤）
如果网站没有使用CDN技术：
1. 用户输入URL之后，浏览器根据URL查询浏览器DNS缓存，返回对应的IP地址。
2. 若查不到缓存，检查域名是否在本地Hosts里。
3. 若本地hosts中没有找到，则使用DNS协议，向本地DNS服务器（本地会记录DNS服务器的IP地址，一般是路由器或者是ISP提供的DNS服务器）发送DNS请求（DNS协议）。DNS服务器解析域名，返回对应的IP地址。
3. 若本地DNS服务器解析不到域名，则会向上层DNS服务器发起域名解析请求。这是一个递归的过程，逐级向上层递交请求，直到查询到IP，最后再层层下发并缓存IP地址。最后本地DNS服务器一定会返回一个IP地址给浏览器。


如果网站使用CDN技术：（用户不会有任何与原来不同的感觉）
1. 用户输入URL之后，浏览器根据URL向DNS服务器发送DNS请求。DNS服务器最后不会直接返回目的IP地址，而是将会请求交给CNAME指向的CDN专用DNS服务器，返回CDN专用DNS服务器的IP地址。
> CNAME：CNAME可以理解为域名的指针引用。

2. 浏览器向CDN专用DNS服务器发送DNS请求，DNS通过负载均衡，综合考虑缓存服务器负载、网络距离和拥塞情况，计算出最适合该用户的缓存服务器，并返回该缓存服务器的IP地址。

具体详见：http://book.51cto.com/art/201205/338756.htm

## 3.  浏览器发送HTTP请求（使用HTTPS协议，则略过该步骤）
根据OSI七层网络模型，浏览器发送HTTP请求主要流程：从应用层的发送HTTP请求报文，到传输层通过三次握手建立TCP连接，再到网络层的IP路由寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

### 3.1  浏览器发送HTTP请求
针对目标URL生成HTTP请求报文。
一个HTTP请求报文由三部分构成：请求行(方法、URL、版本号)、请求头、请求主体。
记序号及端口号后转发给网络层进行IP路由。
> HTTP的具体内容可以查看我文章：[《HTTP》](https://leeyixuan.github.io/2018/05/14/http/)

### 3.2 TCP三次握手建立连接
传输层把从应用层接收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层进行IP路由。
> TCP的具体内容可以查看我文章：[《TCP》](https://leeyixuan.github.io/2018/05/12/tcp/)

### 3.3 IP路由寻址
发送数据包时所使用的地址是网络层的地址，即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由表。本地和路由器都维护着局部的路由表。路由表具有自动学习的功能，能够不断添加新的路由信息。


### 3.4 ARP查询MAC地址
ARP协议也是网络层的协议，ARP根据目的地的IP地址反查出MAC地址。
具体过程：
主机广播ARP请求（包含源IP地址、源MAC地址、目的IP地址）到网络上的所有主机；   
如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。只有目标主机会并接收返回消息，以此确定目标的MAC地址；     
本地收到返回消息后将该IP地址和MAC地址存入本地缓存，下次请求时直接查询本地缓存以节约资源。



## 4.浏览器发送HTTPS请求
根据OSI七层网络模型，浏览器发送HTTPS请求主要流程：从应用层的发送HTTPS请求，**SSL五次握手建立安全连接**，到传输层通过三次握手建立TCP连接，再到网络层的IP路由寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

HTTPS是在HTTP基础上多套了一层SSL安全套接层。SSL位于HTTP和TCP之间。
所以，相比浏览器发送HTTP请求，HTTPS建立安全通信之前，另外有五次安全握手的流程：
第一步，浏览器给出协议版本号、一个随机数（Client random），以及加密方法。

第二步，服务器确认双方使用的加密方法，并给出数字证书、以及一个随机数（Server random）。

第三步，浏览器确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。

第四步，服务器使用自己的私钥，获取浏览器发来的随机数（即Premaster secret）。

第五步，浏览器和服务器根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。

>具体详见我之前写过的文章：[《HTTPS》](https://leeyixuan.github.io/2018/05/13/HTTPS/)


## 5. 服务器处理请求
1. 在请求到达服务器之前，有可能会经过缓存服务器或者是代理服务器的处理。NGINX就是典型的代理服务器，他通过反向代理服务器，实现负载均衡。NGINX同时还能实现跨域和缓存的功能，具体实现要看NGINX的配置。
>正向代理代理客户端；反向代理代理服务器。

2. 请求到达服务器之后，会先进行验证。验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（譬如查询数据库，大量计算等等）

3. 等程序执行完毕后，就会返回一个http响应包（一般这一步也会经过多层封装）。


## 6. 服务器返回HTTP响应
HTTP响应头部字段和HTTP请求头部会有些不同，其他地方区别不大。
HTTP响应头部字段的四个字段（Expires，Cache-Control，Last-Modified，Etag）会控制浏览器缓存。
>具体内容见我之前写过的文章：[《浏览器缓存的一切》](https://leeyixuan.github.io/2018/07/03/cache/)

另外，HTTP响应头部字段的`set-cookie`控制cookie。
>具体内容见我之前写过的文章：[《cookie》](https://leeyixuan.github.io/2018/04/15/cookie/)

## 7. 浏览器解析渲染页面
![](https://www.github.com/CoolRabbit520/photos/raw/master/小书匠/1531706788129.png)



1. 下载HTML文件
2. HTML文件下载完成，进入浏览器的渲染线程，正式开始绘制页面。(css的下载是异步并行的)
3. 解析 HTML 标记并构建 DOM 树。
	- 在这个过程中，遇到CSS文件和图片等资源，会把他们加入到下载队列，并行下载
	- 在这个过程中，遇到JS文件，**暂停渲染线程，开启JS脚本执行线程**开始下载JS文件，文件下载完毕之后立即执行。
4. 解析 CSS 标记并构建 CSSOM 树。
5. 将 DOM 与 CSSOM 合并成一个Render渲染树。
6. 根据渲染树来布局，以计算每个节点在屏幕中的位置。
7. 将各个节点绘制到屏幕上。

>具体内容见我之前写过的文章：[《浏览器加载页面过程》](https://leeyixuan.github.io/2017/07/11/render/)


## 8. 浏览器JS引擎解析

1. 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶，继续执行代码。
2. 每进入函数作用域，创建函数执行上下文，并把它压入执行栈的顶部。
3. 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈。
4. 进入下一个函数上下文。

>具体内容见我之前写过的文章：[《深入学习执行上下文和作用域》](https://leeyixuan.github.io/2017/09/26/scope/)


在执行代码的同时，会触发一些异步操作。异步操作响应之后，回调函数被添加到任务队列中等待执行。主执行栈中同步任务执行完毕之后，会依次轮询任务队列里中的回调函数。事件循环是实现JS异步的关键。

>事件循环的具体内容见我之前写过的文章：[《深入理解JS事件循环》](https://leeyixuan.github.io/2018/03/12/eventloop/)


在执行代码的同时，JS引擎会定期进行垃圾回收，然后释放其内存，这主要针对函数内部的局部变量。

>垃圾回收内存管理的具体内容见我之前写过的文章：[《JS中的垃圾收集和内存管理》](https://leeyixuan.github.io/2018/06/11/garbage/)
