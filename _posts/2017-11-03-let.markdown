---
layout:     post
title:      "let & const & var"
subtitle:   ""
date:       2017-11-3
author:     "leeyixuan"
header-img: "img/background/post-bg-z-index.jpg"
tags:
    - ES6
---

## let
### 1. 块级作用域
let声明的变量只在它所在的代码块有效，仅在块级作用域内有效。

for循环的计数器，就很合适使用let命令。
```
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```

```
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
```
### 2. 不存在变量名提升


ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。不存在变量名提升，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。就算是使用typeof也会报错。作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。
```
// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;

```
不存在变量名提升，导致**暂时性死区**。暂时性死区是指：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明。变量的那一行代码出现，才可以获取和使用该变量。

### 3. 不允许重复声明
不允许重复声明，重复声明则报错。



```
var tmp = new Date();

function f() {	//块级作用域，变量对象内部有tmp，不需要沿着作用域链查找外层的tmp
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```


## const
1. const的作用域与let命令相同：只在声明所在的块级作用域内有效。
2. const声明一个**只读**的常量。一旦声明，常量的值就**不能改变**。
3. 改变常量的值会报错。const一旦声明变量，就必须立即初始化，不能留到以后赋值。

4. const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。

**注意**：
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个**内存地址**不得改动。
- 对于简单类型的数据（数值、字符串、布尔值），**值**就保存在变量指向的那个内存地址，因此等同于常量。
- 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个**指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了**。



## var和let的区别

### 1. 作用域


ES5只有全局作用域和函数作用域，没有块级作用域。ES6因为let和const的出现，在某种意义上实现了块级作用域。


- var声明的变量是以函数作用域链为基准的。var声明的变量的作用域是整个封闭**函数**。
- let和其他函数语言相似，具有“块级作用域”。let声明的变量只在其声明的**块或子块**中可用。


### 2. 变量提升

- let不可重复定义，会有暂时性死区
- var有函数声明提升和变量声明提升

### 3. 重复声明
- let不可重复声明，会有报错
- var可以重复声明，后声明的变量覆盖之前声明的




## let相比于var的先进性
### 1. 块级作用域

开辟块块级作用域的概念，天然具有私有接口，避免使用闭包。

在循环中使用let定义变量，既可以在循环体外实现**隐身**，又可以在循环体中使用每一个**实时数据**（因为每一次循环都对应一个独立的块级作用域，这避免了闭包的使用）。



### 2. 顶层对象和全局对象脱钩
顶层对象的属性与全局变量是等价的。    
在浏览器环境中，顶层对象是window，指的是浏览器的窗口对象。    
var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，**不属于顶层对象的属性**。
```
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
```