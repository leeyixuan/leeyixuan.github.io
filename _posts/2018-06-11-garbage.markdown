---
layout:     post
title:      "JS中的垃圾收集和内存管理"
subtitle:   ""
date:       2018-6-11
author:     "leeyixuan"
header-img: "img/background/post-bg-js.jpg"
tags:
    - js
---
## 内存管理
全局变量和全局对象一直存在在内存中，局部变量会在他们离开执行环境时自动解除引用。
### 解除引用
对于全局变量和全局对象，必要时（这些变量之后不会再被使用），将值设为null来释放其引用。
对于函数内部的局部变量，在：
- 解除**循环引用**时，将值设为null来释放其引用。
- 解除**闭包**的内存泄漏时，将值设为null来释放其引用。


## 垃圾收集
**定期**找到那些不再继续使用的变量，然后释放其内存。
主要针对函数内部的局部变量。

有两种**找到不再使用的变量**的方法：
1. 标记清除
保留：环境中的变量以及环境中的变量引用的变量 

2. 引用计数
丢弃：不再被任何变量引用的值（无法再访问的值）
**内存泄漏**：在IE9之前的BOM和DOM对象出现**循环引用**就会导致内存泄漏。
![](https://www.github.com/CoolRabbit520/photos/raw/master/小书匠/循环引用.png)
例子：这里element作为一个DOM对象出现了循环引用的现象，带来了引用计数的问题。需要在后面：
`myObject.element=null;element.someObject=null;`
![](https://www.github.com/CoolRabbit520/photos/raw/master/小书匠/1523534096473.jpg)

## 闭包与内存泄漏
包含函数在执行完毕之后，因为闭包的存在（闭包的作用域链上含有还包含函数），虽然包含函数的作用域链被销毁，但是他的活动对象仍然保留在内存中。直到匿名函数被销毁（1. 闭包被注册为全局变量，手动解除引用；2. 当闭包作为return值被原地执行，执行结束），包含函数的活动对象才会从内存中清除。

即使闭包不直接引用包含函数内部的对象，包含函数也仍然会被视为是被闭包引用的对象（作用域链），因此需要手动解除引用（手动将包含函数内部的局部变量全设为null）。

![](https://www.github.com/CoolRabbit520/photos/raw/master/小书匠/1523534837423.jpg)