---
layout:     post
title:      "JS中的垃圾收集和内存管理"
date:       2018-6-11
author:     "leeyixuan"
header-img: "img/background/post-bg-js.jpg"
tags:
    - js
---
## 内存管理
全局变量和全局对象一直存在在内存中，局部变量会在他们离开执行环境时自动解除引用。
## 强制解除引用
对于全局变量和全局对象，必要时（这些变量之后不会再被使用），将值设为null来释放其引用。    

对于函数内部的局部变量，
- 解除循环引用时，将值设为null来释放其引用。
- 解除闭包的内存泄漏时，将值设为null来释放其引用。


## 垃圾收集
**定期**找到那些不再继续使用的变量，然后释放其内存。主要针对函数内部的局部变量。   

有两种**找到不再使用的变量**的方法：   
1.标记清除：保留环境中的变量以及环境中的变量引用的变量     
2.引用计数：丢弃不再被任何变量引用的值（无法再访问的值） 

## 循环引用与内存泄漏 
如果使用引用计数，并且在IE9之前的BOM和DOM对象出现**循环引用**就会导致内存泄漏。
 <img  width="300"  src="https://www.github.com/CoolRabbit520/photos/raw/master/小书匠/1532487411264.png" />
看一个循环引用导致内存泄漏的例子：
```javascript
var element = document.getElementById('some_element');
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;

```
这里element作为一个DOM对象出现了循环引用的现象，带来了引用计数的问题。
需要在后面强制解除引用：
```javascript
myObject.element = null;
element.someObject = null;
```
## 闭包与内存泄漏
闭包使用不当会导致内存泄漏。

我们使用闭包的原因之一就是：闭包的作用域链上含有父作用域，保留父作用域变量对象的引用，因此闭包可以延长变量的生命周期。但是当不使用父作用域的变量时，仍不手动解除引用，使其存在于父变量对象中，那么就会导致内存泄漏。

>包含函数在执行完毕之后，因为闭包的存在，虽然包含函数的上下文已经离开执行环境，但是他的活动对象仍然保留在内存中，直到匿名函数被销毁（1. 闭包被注册为全局变量，手动解除引用；2. 当闭包作为return值被原地执行，执行结束），包含函数的活动对象才会从内存中清除。

**注意**：    
即使闭包不直接引用包含函数内部的对象，包含函数也仍然会被视为是被闭包引用的对象，因此需要手动强制解除引用，手动将包含函数内部的局部变量全设为null。


## 移除DOM节点与内存泄漏

1.一个变量暂存DOM节点，接下来使用的时候就不用再从DOM中去获取。但是在移除DOM节点的时候却忘记了解除暂存的变量对DOM节点的引用，会造成内存泄漏。

2.DOM节点绑定了事件，但是在移除的时候没有解除事件绑定，那么仅仅移除DOM 节点也会造成内存泄漏。

